export class Block {
  static calculateMerkleRoot(transactions: any, forWitness: any): any;
  static calculateTarget(bits: any): any;
  static fromBuffer(buffer: any): any;
  static fromHex(hex: any): any;
  version: any;
  prevHash: any;
  merkleRoot: any;
  timestamp: any;
  witnessCommit: any;
  bits: any;
  nonce: any;
  transactions: any;
  byteLength(headersOnly: any): any;
  checkProofOfWork(): any;
  checkTxRoots(): any;
  getHash(): any;
  getId(): any;
  getUTCDate(): any;
  getWitnessCommit(): any;
  hasWitness(): any;
  hasWitnessCommit(): any;
  toBuffer(headersOnly: any): any;
  toHex(headersOnly: any): any;
}
export namespace ECPair {
  function fromPrivateKey(buffer: any, options: any): any;
  function fromPublicKey(buffer: any, options: any): any;
  function fromWIF(wifString: any, network: any): any;
  function makeRandom(options: any): any;
}
export class Transaction {
  static ADVANCED_TRANSACTION_FLAG: number;
  static ADVANCED_TRANSACTION_MARKER: number;
  static DEFAULT_SEQUENCE: number;
  static SIGHASH_ALL: number;
  static SIGHASH_ANYONECANPAY: number;
  static SIGHASH_NONE: number;
  static SIGHASH_SINGLE: number;
  static fromBuffer(buffer: any, _NO_STRICT: any): any;
  static fromHex(hex: any): any;
  static isCoinbaseHash(buffer: any): any;
  version: any;
  locktime: any;
  ins: any;
  outs: any;
  addInput(hash: any, index: any, sequence: any, scriptSig: any, ...args: any[]): any;
  addOutput(scriptPubKey: any, value: any, ...args: any[]): any;
  byteLength(): any;
  clone(): any;
  getHash(forWitness: any): any;
  getId(): any;
  hasWitnesses(): any;
  hashForSignature(inIndex: any, prevOutScript: any, hashType: any, ...args: any[]): any;
  hashForWitnessV0(inIndex: any, prevOutScript: any, value: any, hashType: any, ...args: any[]): any;
  isCoinbase(): any;
  setInputScript(index: any, scriptSig: any, ...args: any[]): void;
  setWitness(index: any, witness: any, ...args: any[]): void;
  toBuffer(buffer: any, initialOffset: any): any;
  toHex(): any;
  virtualSize(): any;
  weight(): any;
}
export class TransactionBuilder {
  static fromTransaction(transaction: any, network: any): any;
  constructor(network: any, maximumFeeRate: any);
  network: any;
  maximumFeeRate: any;
  addInput(txHash: any, vout: any, sequence: any, prevOutScript: any): any;
  addOutput(scriptPubKey: any, value: any): any;
  build(): any;
  buildIncomplete(): any;
  setLockTime(locktime: any): void;
  setLowR(setting: any): any;
  setVersion(version: any): void;
  sign(vin: any, keyPair: any, redeemScript: any, hashType: any, witnessValue: any, witnessScript: any): void;
}
export namespace address {
  function fromBase58Check(address: any): any;
  function fromBech32(address: any): any;
  function fromOutputScript(output: any, network: any): any;
  function toBase58Check(hash: any, version: any, ...args: any[]): any;
  function toBech32(data: any, version: any, prefix: any): any;
  function toOutputScript(address: any, network: any): any;
}
export namespace bip32 {
  function fromBase58(inString: any, network: any): any;
  function fromPrivateKey(privateKey: any, chainCode: any, network: any): any;
  function fromPublicKey(publicKey: any, chainCode: any, network: any): any;
  function fromSeed(seed: any, network: any): any;
}
export namespace crypto {
  function hash160(buffer: any): any;
  function hash256(buffer: any): any;
  function ripemd160(buffer: any): any;
  function sha1(buffer: any): any;
  function sha256(buffer: any): any;
}
export const networks: {
  bitcoin: {
    bech32: string;
    bip32: {
      private: number;
      public: number;
    };
    messagePrefix: string;
    pubKeyHash: number;
    scriptHash: number;
    wif: number;
  };
  regtest: {
    bech32: string;
    bip32: {
      private: number;
      public: number;
    };
    messagePrefix: string;
    pubKeyHash: number;
    scriptHash: number;
    wif: number;
  };
  testnet: {
    bech32: string;
    bip32: {
      private: number;
      public: number;
    };
    messagePrefix: string;
    pubKeyHash: number;
    scriptHash: number;
    wif: number;
  };
};
export const opcodes: {
  OP_0: number;
  OP_0NOTEQUAL: number;
  OP_1: number;
  OP_10: number;
  OP_11: number;
  OP_12: number;
  OP_13: number;
  OP_14: number;
  OP_15: number;
  OP_16: number;
  OP_1ADD: number;
  OP_1NEGATE: number;
  OP_1SUB: number;
  OP_2: number;
  OP_2DIV: number;
  OP_2DROP: number;
  OP_2DUP: number;
  OP_2MUL: number;
  OP_2OVER: number;
  OP_2ROT: number;
  OP_2SWAP: number;
  OP_3: number;
  OP_3DUP: number;
  OP_4: number;
  OP_5: number;
  OP_6: number;
  OP_7: number;
  OP_8: number;
  OP_9: number;
  OP_ABS: number;
  OP_ADD: number;
  OP_AND: number;
  OP_BOOLAND: number;
  OP_BOOLOR: number;
  OP_CAT: number;
  OP_CHECKLOCKTIMEVERIFY: number;
  OP_CHECKMULTISIG: number;
  OP_CHECKMULTISIGVERIFY: number;
  OP_CHECKSEQUENCEVERIFY: number;
  OP_CHECKSIG: number;
  OP_CHECKSIGVERIFY: number;
  OP_CODESEPARATOR: number;
  OP_DEPTH: number;
  OP_DIV: number;
  OP_DROP: number;
  OP_DUP: number;
  OP_ELSE: number;
  OP_ENDIF: number;
  OP_EQUAL: number;
  OP_EQUALVERIFY: number;
  OP_FALSE: number;
  OP_FROMALTSTACK: number;
  OP_GREATERTHAN: number;
  OP_GREATERTHANOREQUAL: number;
  OP_HASH160: number;
  OP_HASH256: number;
  OP_IF: number;
  OP_IFDUP: number;
  OP_INVALIDOPCODE: number;
  OP_INVERT: number;
  OP_LEFT: number;
  OP_LESSTHAN: number;
  OP_LESSTHANOREQUAL: number;
  OP_LSHIFT: number;
  OP_MAX: number;
  OP_MIN: number;
  OP_MOD: number;
  OP_MUL: number;
  OP_NEGATE: number;
  OP_NIP: number;
  OP_NOP: number;
  OP_NOP1: number;
  OP_NOP10: number;
  OP_NOP2: number;
  OP_NOP3: number;
  OP_NOP4: number;
  OP_NOP5: number;
  OP_NOP6: number;
  OP_NOP7: number;
  OP_NOP8: number;
  OP_NOP9: number;
  OP_NOT: number;
  OP_NOTIF: number;
  OP_NUMEQUAL: number;
  OP_NUMEQUALVERIFY: number;
  OP_NUMNOTEQUAL: number;
  OP_OR: number;
  OP_OVER: number;
  OP_PICK: number;
  OP_PUBKEY: number;
  OP_PUBKEYHASH: number;
  OP_PUSHDATA1: number;
  OP_PUSHDATA2: number;
  OP_PUSHDATA4: number;
  OP_RESERVED: number;
  OP_RESERVED1: number;
  OP_RESERVED2: number;
  OP_RETURN: number;
  OP_RIGHT: number;
  OP_RIPEMD160: number;
  OP_ROLL: number;
  OP_ROT: number;
  OP_RSHIFT: number;
  OP_SHA1: number;
  OP_SHA256: number;
  OP_SIZE: number;
  OP_SUB: number;
  OP_SUBSTR: number;
  OP_SWAP: number;
  OP_TOALTSTACK: number;
  OP_TRUE: number;
  OP_TUCK: number;
  OP_VER: number;
  OP_VERIF: number;
  OP_VERIFY: number;
  OP_VERNOTIF: number;
  OP_WITHIN: number;
  OP_XOR: number;
};
export namespace payments {
  function embed(a: any, opts: any): any;
  function p2ms(a: any, opts: any): any;
  function p2pk(a: any, opts: any): any;
  function p2pkh(a: any, opts: any): any;
  function p2sh(a: any, opts: any): any;
  function p2wpkh(a: any, opts: any): any;
  function p2wsh(a: any, opts: any): any;
}
export namespace script {
  const OPS: {
    OP_0: number;
    OP_0NOTEQUAL: number;
    OP_1: number;
    OP_10: number;
    OP_11: number;
    OP_12: number;
    OP_13: number;
    OP_14: number;
    OP_15: number;
    OP_16: number;
    OP_1ADD: number;
    OP_1NEGATE: number;
    OP_1SUB: number;
    OP_2: number;
    OP_2DIV: number;
    OP_2DROP: number;
    OP_2DUP: number;
    OP_2MUL: number;
    OP_2OVER: number;
    OP_2ROT: number;
    OP_2SWAP: number;
    OP_3: number;
    OP_3DUP: number;
    OP_4: number;
    OP_5: number;
    OP_6: number;
    OP_7: number;
    OP_8: number;
    OP_9: number;
    OP_ABS: number;
    OP_ADD: number;
    OP_AND: number;
    OP_BOOLAND: number;
    OP_BOOLOR: number;
    OP_CAT: number;
    OP_CHECKLOCKTIMEVERIFY: number;
    OP_CHECKMULTISIG: number;
    OP_CHECKMULTISIGVERIFY: number;
    OP_CHECKSEQUENCEVERIFY: number;
    OP_CHECKSIG: number;
    OP_CHECKSIGVERIFY: number;
    OP_CODESEPARATOR: number;
    OP_DEPTH: number;
    OP_DIV: number;
    OP_DROP: number;
    OP_DUP: number;
    OP_ELSE: number;
    OP_ENDIF: number;
    OP_EQUAL: number;
    OP_EQUALVERIFY: number;
    OP_FALSE: number;
    OP_FROMALTSTACK: number;
    OP_GREATERTHAN: number;
    OP_GREATERTHANOREQUAL: number;
    OP_HASH160: number;
    OP_HASH256: number;
    OP_IF: number;
    OP_IFDUP: number;
    OP_INVALIDOPCODE: number;
    OP_INVERT: number;
    OP_LEFT: number;
    OP_LESSTHAN: number;
    OP_LESSTHANOREQUAL: number;
    OP_LSHIFT: number;
    OP_MAX: number;
    OP_MIN: number;
    OP_MOD: number;
    OP_MUL: number;
    OP_NEGATE: number;
    OP_NIP: number;
    OP_NOP: number;
    OP_NOP1: number;
    OP_NOP10: number;
    OP_NOP2: number;
    OP_NOP3: number;
    OP_NOP4: number;
    OP_NOP5: number;
    OP_NOP6: number;
    OP_NOP7: number;
    OP_NOP8: number;
    OP_NOP9: number;
    OP_NOT: number;
    OP_NOTIF: number;
    OP_NUMEQUAL: number;
    OP_NUMEQUALVERIFY: number;
    OP_NUMNOTEQUAL: number;
    OP_OR: number;
    OP_OVER: number;
    OP_PICK: number;
    OP_PUBKEY: number;
    OP_PUBKEYHASH: number;
    OP_PUSHDATA1: number;
    OP_PUSHDATA2: number;
    OP_PUSHDATA4: number;
    OP_RESERVED: number;
    OP_RESERVED1: number;
    OP_RESERVED2: number;
    OP_RETURN: number;
    OP_RIGHT: number;
    OP_RIPEMD160: number;
    OP_ROLL: number;
    OP_ROT: number;
    OP_RSHIFT: number;
    OP_SHA1: number;
    OP_SHA256: number;
    OP_SIZE: number;
    OP_SUB: number;
    OP_SUBSTR: number;
    OP_SWAP: number;
    OP_TOALTSTACK: number;
    OP_TRUE: number;
    OP_TUCK: number;
    OP_VER: number;
    OP_VERIF: number;
    OP_VERIFY: number;
    OP_VERNOTIF: number;
    OP_WITHIN: number;
    OP_XOR: number;
  };
  function compile(chunks: any): any;
  function decompile(buffer: any): any;
  function fromASM(asm: any): any;
  function isCanonicalPubKey(buffer: any): any;
  function isCanonicalScriptSignature(buffer: any): any;
  function isDefinedHashType(hashType: any): any;
  function isPushOnly(value: any): any;
  namespace number {
    function decode(buffer: any, maxLength: any, minimal: any): any;
    function encode(_number: any): any;
  }
  namespace signature {
    function decode(buffer: any): any;
    function encode(signature: any, hashType: any): any;
  }
  function toASM(chunks: any): any;
  function toStack(chunks: any): any;
}
